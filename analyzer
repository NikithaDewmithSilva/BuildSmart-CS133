import ezdxf
import math

# File path to the DXF file (update as needed)
FILE_PATH = r"C:\Users\atcha\OneDrive\Documents\Baticaloa.dxf"

# Load the DXF file and access the modelspace
try:
    doc = ezdxf.readfile(FILE_PATH)
    msp = doc.modelspace()
except FileNotFoundError:
    print(f"Error: File '{FILE_PATH}' not found.")
    exit(1)
except ezdxf.DXFStructureError as e:
    print(f"Error: Invalid DXF file structure - {e}")
    exit(1)

# Initialize counters and accumulators
walls = 0
doors = 0
windows = 0
total_area = 0.0
total_wall_area = 0.0

# Define labels for identifying components
DOOR_LABELS = ["D1", "D2", "RSD", "DOOR"]
WINDOW_LABELS = ["FW", "W1", "SW", "FL", "WINDOW"]

def infer_material(entity):
    """Infer the material or component type based on layer, block name, or text."""
    try:
        if hasattr(entity, 'dxf') and hasattr(entity.dxf, 'layer'):
            layer_name = entity.dxf.layer.upper()
            if "WALL" in layer_name:
                return "WALL"
            elif any(label in layer_name for label in DOOR_LABELS):
                return "DOOR"
            elif any(label in layer_name for label in WINDOW_LABELS):
                return "WINDOW"
        
        if entity.dxftype() == 'INSERT':
            block_name = entity.dxf.name.upper()
            if any(label in block_name for label in DOOR_LABELS):
                return "DOOR"
            elif any(label in block_name for label in WINDOW_LABELS):
                return "WINDOW"
        
        if entity.dxftype() in ['TEXT', 'MTEXT']:
            text = entity.dxf.text.upper()
            if any(label in text for label in DOOR_LABELS):
                return "DOOR"
            elif any(label in text for label in WINDOW_LABELS):
                return "WINDOW"
        
        return None
    except AttributeError:
        return None

def calculate_area(entity):
    """Calculate the area of a given entity."""
    try:
        if entity.dxftype() == 'LWPOLYLINE' and hasattr(entity, 'get_area'):
            return entity.get_area()
        elif entity.dxftype() == 'CIRCLE':
            return math.pi * (entity.dxf.radius ** 2)
        elif entity.dxftype() == 'ARC':
            radius = entity.dxf.radius
            angle = math.radians(entity.dxf.end_angle - entity.dxf.start_angle)
            return 0.5 * (radius ** 2) * angle
        elif entity.dxftype() == 'HATCH':
            return sum(path.area for path in entity.paths if hasattr(path, 'area'))
        return 0.0
    except Exception as e:
        print(f"Error calculating area for {entity.dxftype()}: {e}")
        return 0.0

def estimate_wall_area(line1, line2):
    """Estimate the area of a wall from two parallel lines."""
    try:
        x1, y1 = line1.dxf.start.x, line1.dxf.start.y
        x2, y2 = line1.dxf.end.x, line1.dxf.end.y
        x3, y3 = line2.dxf.start.x, line2.dxf.start.y
        x4, y4 = line2.dxf.end.x, line2.dxf.end.y

        # Calculate line lengths
        length1 = math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)
        length2 = math.sqrt((x4 - x3) ** 2 + (y4 - y3) ** 2)
        wall_length = min(length1, length2)  # Use shorter length as wall length
        
        # Approximate wall thickness (perpendicular distance)
        wall_thickness = abs(x1 - x3) + abs(y1 - y3)
        
        return wall_length * wall_thickness
    except Exception as e:
        print(f"Error estimating wall area: {e}")
        return 0.0

def count_entities():
    """Count entities and calculate areas from the DXF modelspace."""
    global walls, doors, windows, total_area, total_wall_area
    wall_lines = []

    # First pass: Identify and count entities
    for entity in msp:
        material = infer_material(entity)
        if material == "WALL":
            walls += 1
            if entity.dxftype() in ['LWPOLYLINE', 'HATCH']:
                total_wall_area += calculate_area(entity)
            elif entity.dxftype() == 'LINE':
                wall_lines.append(entity)
        elif material == "DOOR":
            doors += 1
        elif material == "WINDOW":
            windows += 1

    # Estimate wall areas from pairs of lines
    while len(wall_lines) >= 2:
        line1 = wall_lines.pop(0)
        line2 = wall_lines.pop(0)
        total_wall_area += estimate_wall_area(line1, line2)

    # Calculate total area from arcs, circles, and hatches
    for entity in msp.query("ARC CIRCLE HATCH"):
        total_area += calculate_area(entity)

# Execute the counting and area calculation
count_entities()

# Output Summary
print("Summary:")
print(f"Detected Walls: {walls}")
print(f"Detected Doors: {doors}")
print(f"Detected Windows: {windows}")
print(f"Total Area: {total_area:.2f} sq units")
print(f"Total Wall Area: {total_wall_area:.2f} sq units")
print()  # Blank line for separation

# Estimate material requirements if walls are detected
if walls > 0:
    bricks_needed = int(total_wall_area * 7)  # 7 bricks per sq unit
    
    # Cement: mortar (0.25 kg/brick) + concrete (350 kg/m続)
    cement_for_mortar = bricks_needed * 0.25
    concrete_volume = total_wall_area * 0.1  # 0.1 m続 per sq unit
    cement_for_concrete = concrete_volume * 350
    cement_needed_kg = cement_for_mortar + cement_for_concrete
    cement_needed_bags = cement_needed_kg / 50  # 50 kg per bag
    
    # Gravel: 1,000 kg per m続 of concrete
    gravel_needed_kg = concrete_volume * 1000
    
    # Sand: mortar (0.15 kg/brick) + concrete (600 kg/m続)
    sand_for_mortar = bricks_needed * 0.15
    sand_for_concrete = concrete_volume * 600
    sand_needed_kg = sand_for_mortar + sand_for_concrete
    
    # Output Estimated Material
    print("Estimated Material Output:")
    print(f"Estimated bricks required: {bricks_needed}")
    print(f"Estimated cement required: {cement_needed_bags:.2f} bags ({cement_needed_kg:.2f} kg)")
    print(f"Estimated gravel required: {gravel_needed_kg:.2f} kg")
    print(f"Estimated sand required: {sand_needed_kg:.2f} kg")
else:
    print("No walls detected to calculate material requirements.")